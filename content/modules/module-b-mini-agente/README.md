# M√≥dulo B: Primer Mini-Agente
## Patr√≥n Planner‚ÜíExecutor‚ÜíCritic ‚Ä¢ Tool Calling Seguro ‚Ä¢ Manejo de Errores

---

### üéØ Objetivos del M√≥dulo

Al finalizar este m√≥dulo ser√°s capaz de:
- **Implementar** un agente siguiendo el patr√≥n Planner-Executor-Critic (PEC)
- **Integrar** tool calling seguro con validaci√≥n de herramientas
- **Manejar** errores y flujos de recuperaci√≥n en agentes
- **Evaluar** resultados y tomar decisiones de retry/abort
- **Crear** un agente aut√≥nomo que puede completar tareas complejas

**‚è±Ô∏è Duraci√≥n estimada:** 3-4 horas  
**üîß Prerrequisitos:** M√≥dulo A completado, conceptos de APIs, JSON Schema

---

## 1. Arquitectura del Patr√≥n PEC

### 1.1 ¬øQu√© es el Patr√≥n Planner-Executor-Critic?

El patr√≥n **PEC** divide la responsabilidad del agente en tres componentes especializados:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    AGENTE PEC                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   PLANNER   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  EXECUTOR   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   CRITIC    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ    ‚îÇ             ‚îÇ    ‚îÇ             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Analiza   ‚îÇ    ‚îÇ ‚Ä¢ Ejecuta   ‚îÇ    ‚îÇ ‚Ä¢ Eval√∫a    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Planifica ‚îÇ    ‚îÇ ‚Ä¢ Herramient‚îÇ    ‚îÇ ‚Ä¢ Decide    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Estructura‚îÇ    ‚îÇ ‚Ä¢ Acciones  ‚îÇ    ‚îÇ ‚Ä¢ Retry/Ok  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ         ‚îÇ                    ‚îÇ                    ‚îÇ     ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FEEDBACK LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1.2 Responsabilidades de Cada Componente

**üß† PLANNER (Planificador)**
- Analizar el objetivo del usuario
- Descomponer en pasos ejecutables
- Seleccionar herramientas apropiadas
- Generar plan estructurado en JSON

**‚ö° EXECUTOR (Ejecutor)**
- Ejecutar cada paso del plan
- Llamar a herramientas externas
- Manejar par√°metros y validaciones
- Capturar resultados y errores

**üë®‚Äç‚öñÔ∏è CRITIC (Cr√≠tico)**
- Evaluar si los resultados son satisfactorios
- Detectar errores o resultados incompletos
- Decidir si continuar, reintentar o abortar
- Proporcionar feedback para mejoras

### 1.3 Ventajas del Patr√≥n PEC

‚úÖ **Modularidad**: Cada componente tiene responsabilidad clara  
‚úÖ **Testabilidad**: Se puede probar cada parte independientemente  
‚úÖ **Debugging**: F√°cil identificar d√≥nde ocurren problemas  
‚úÖ **Escalabilidad**: Se pueden mejorar componentes por separado  
‚úÖ **Robustez**: Manejo de errores distribuido y especializado  

---

## 2. Dise√±o del Mini-Agente

### 2.1 Especificaci√≥n del Agente

Nuestro mini-agente ser√° capaz de:
- üîç **Buscar informaci√≥n** en documentos
- üßÆ **Realizar c√°lculos** matem√°ticos
- üìÑ **Formatear respuestas** en diferentes estilos
- ‚è∞ **Obtener fecha/hora** actual
- üåê **Consultar APIs** externas (simuladas)

### 2.2 Schema del Plan de Ejecuci√≥n

```json
{
  "plan_id": "plan_20250816_143022",
  "goal": "Buscar informaci√≥n sobre Python y calcular estad√≠sticas",
  "steps": [
    {
      "step_id": 1,
      "action": "search",
      "tool": "search_documents",
      "parameters": {
        "query": "Python programming language",
        "max_results": 3
      },
      "expected_output": "lista de documentos relevantes",
      "validation_criteria": ["al menos 1 resultado", "relevancia > 0.7"]
    },
    {
      "step_id": 2,
      "action": "calculate",
      "tool": "math_calculator", 
      "parameters": {
        "expression": "len(results) * 100 / total_docs"
      },
      "expected_output": "porcentaje de relevancia",
      "validation_criteria": ["resultado num√©rico", "0 <= valor <= 100"]
    }
  ],
  "success_criteria": [
    "informaci√≥n recuperada exitosamente",
    "c√°lculos completados sin errores",
    "respuesta formateada correctamente"
  ],
  "max_retries": 3,
  "timeout_seconds": 30
}
```

### 2.3 Herramientas Disponibles

| Herramienta | Descripci√≥n | Par√°metros | Salida |
|-------------|-------------|------------|---------|
| `search_documents` | Buscar en base de conocimiento | `query`, `max_results` | Lista de documentos |
| `math_calculator` | Calcular expresiones matem√°ticas | `expression` | Resultado num√©rico |
| `format_response` | Formatear texto en diferentes estilos | `content`, `format` | Texto formateado |
| `get_current_time` | Obtener fecha y hora actual | `timezone` | Timestamp |
| `weather_api` | Consultar clima (simulado) | `location` | Datos meteorol√≥gicos |

---

## 3. Implementaci√≥n del Planner

### 3.1 Clase BasePlanner

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any
from datetime import datetime
import json

class BasePlanner(ABC):
    """Clase base para planificadores de agentes"""
    
    def __init__(self, available_tools: List[str]):
        self.available_tools = set(available_tools)
        self.plan_counter = 0
    
    @abstractmethod
    def create_plan(self, goal: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Crear plan de ejecuci√≥n para el objetivo dado"""
        pass
    
    def validate_plan(self, plan: Dict[str, Any]) -> tuple[bool, str]:
        """Validar que el plan sea ejecutable"""
        # Verificar estructura b√°sica
        required_fields = ['plan_id', 'goal', 'steps']
        for field in required_fields:
            if field not in plan:
                return False, f"Campo requerido faltante: {field}"
        
        # Verificar que los pasos usen herramientas disponibles
        for step in plan['steps']:
            tool = step.get('tool')
            if tool not in self.available_tools:
                return False, f"Herramienta no disponible: {tool}"
        
        return True, "Plan v√°lido"
    
    def generate_plan_id(self) -> str:
        """Generar ID √∫nico para el plan"""
        self.plan_counter += 1
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"plan_{timestamp}_{self.plan_counter:03d}"
```

### 3.2 SimplePlanner Implementaci√≥n

```python
class SimplePlanner(BasePlanner):
    """Planificador simple que descompone objetivos en pasos"""
    
    def __init__(self, available_tools: List[str]):
        super().__init__(available_tools)
        self.planning_templates = {
            'search_and_calculate': self._search_calculate_template,
            'information_retrieval': self._info_retrieval_template,
            'data_processing': self._data_processing_template
        }
    
    def create_plan(self, goal: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Crear plan basado en an√°lisis del objetivo"""
        
        # Analizar tipo de tarea
        task_type = self._analyze_goal(goal)
        
        # Seleccionar template apropiado
        if task_type in self.planning_templates:
            plan = self.planning_templates[task_type](goal, context)
        else:
            plan = self._default_template(goal, context)
        
        # Validar antes de retornar
        is_valid, message = self.validate_plan(plan)
        if not is_valid:
            raise ValueError(f"Plan inv√°lido generado: {message}")
        
        return plan
    
    def _analyze_goal(self, goal: str) -> str:
        """Analizar el objetivo para determinar tipo de tarea"""
        goal_lower = goal.lower()
        
        if any(word in goal_lower for word in ['buscar', 'encontrar', 'informaci√≥n']):
            if any(word in goal_lower for word in ['calcular', 'contar', 'estad√≠stica']):
                return 'search_and_calculate'
            return 'information_retrieval'
        elif any(word in goal_lower for word in ['procesar', 'transformar', 'formatear']):
            return 'data_processing'
        else:
            return 'general'
```

---

## 4. Implementaci√≥n del Executor

### 4.1 Clase BaseExecutor

```python
class BaseExecutor(ABC):
    """Clase base para ejecutores de planes"""
    
    def __init__(self, tool_registry: 'ToolRegistry'):
        self.tool_registry = tool_registry
        self.execution_log = []
    
    @abstractmethod
    def execute_plan(self, plan: Dict[str, Any]) -> Dict[str, Any]:
        """Ejecutar plan completo"""
        pass
    
    def execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """Ejecutar un paso individual"""
        start_time = datetime.now()
        
        try:
            # Validar paso
            if not self._validate_step(step):
                raise ValueError(f"Paso inv√°lido: {step}")
            
            # Ejecutar herramienta
            tool_name = step['tool']
            parameters = step.get('parameters', {})
            
            result = self.tool_registry.execute_tool(tool_name, parameters)
            
            # Registrar ejecuci√≥n
            execution_record = {
                'step_id': step['step_id'],
                'tool': tool_name,
                'parameters': parameters,
                'result': result,
                'status': 'success',
                'execution_time': (datetime.now() - start_time).total_seconds(),
                'timestamp': datetime.now().isoformat()
            }
            
            self.execution_log.append(execution_record)
            return execution_record
            
        except Exception as e:
            # Registrar error
            error_record = {
                'step_id': step['step_id'],
                'tool': step.get('tool', 'unknown'),
                'parameters': step.get('parameters', {}),
                'error': str(e),
                'status': 'error',
                'execution_time': (datetime.now() - start_time).total_seconds(),
                'timestamp': datetime.now().isoformat()
            }
            
            self.execution_log.append(error_record)
            return error_record
```

---

## 5. Implementaci√≥n del Critic

### 5.1 Clase BaseCritic

```python
class BaseCritic(ABC):
    """Clase base para cr√≠ticos evaluadores"""
    
    def __init__(self, success_threshold: float = 0.8):
        self.success_threshold = success_threshold
        self.evaluation_history = []
    
    @abstractmethod
    def evaluate_execution(self, plan: Dict[str, Any], 
                          execution_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Evaluar resultados de ejecuci√≥n"""
        pass
    
    def evaluate_step(self, step: Dict[str, Any], 
                     result: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluar resultado de un paso individual"""
        
        if result['status'] == 'error':
            return {
                'step_id': step['step_id'],
                'success': False,
                'score': 0.0,
                'issues': [f"Error en ejecuci√≥n: {result.get('error', 'Unknown error')}"],
                'recommendation': 'retry'
            }
        
        # Validar criterios de √©xito del paso
        validation_criteria = step.get('validation_criteria', [])
        passed_validations = 0
        issues = []
        
        for criterion in validation_criteria:
            passed, issue = self._validate_criterion(criterion, result)
            if passed:
                passed_validations += 1
            else:
                issues.append(issue)
        
        # Calcular score
        if validation_criteria:
            score = passed_validations / len(validation_criteria)
        else:
            score = 1.0 if result['status'] == 'success' else 0.0
        
        return {
            'step_id': step['step_id'],
            'success': score >= self.success_threshold,
            'score': score,
            'issues': issues,
            'recommendation': 'continue' if score >= self.success_threshold else 'retry'
        }
```

---

## 6. Laboratorio Pr√°ctico

### 6.1 Ejercicio 1: Implementar Planner B√°sico ‚úÖ

**Objetivo:** Crear un planificador que descomponga objetivos simples

**Archivo:** `labs/module-b/basic_planner.py`

**Estado**: ‚úÖ **COMPLETADO** - SimplePlanner funcional con an√°lisis de objetivos y generaci√≥n de planes estructurados

```python
# ‚úÖ IMPLEMENTADO: SimplePlanner con capacidad de:
# 1. ‚úÖ Analizar objetivos de usuario
# 2. ‚úÖ Generar planes estructurados con dataclasses
# 3. ‚úÖ Validar herramientas disponibles
# 4. ‚úÖ Manejar diferentes tipos de tareas con templates
```

### 6.2 Ejercicio 2: Tool Registry Seguro ‚úÖ

**Objetivo:** Implementar registro de herramientas con validaci√≥n

**Archivo:** `labs/module-b/tool_registry.py`

**Estado**: ‚úÖ **COMPLETADO** - ToolRegistry con circuit breakers, rate limiting y validaci√≥n avanzada

```python
# ‚úÖ IMPLEMENTADO: ToolRegistry que:
# 1. ‚úÖ Registra herramientas de forma segura con validaci√≥n
# 2. ‚úÖ Valida par√°metros con schemas y regex patterns
# 3. ‚úÖ Maneja timeouts y l√≠mites con circuit breakers
# 4. ‚úÖ Registra todas las llamadas para auditor√≠a y m√©tricas
```

### 6.3 Ejercicio 3: Agente PEC Completo ‚úÖ

**Objetivo:** Integrar todos los componentes en un agente funcional

**Archivo:** `labs/module-b/pec_agent.py`

**Estado**: ‚úÖ **COMPLETADO** - PECAgent funcional con executor robusto y critic inteligente

```python
# ‚úÖ IMPLEMENTADO: PECAgent que:
# 1. ‚úÖ Combina Planner + Executor + Critic en flujo completo
# 2. ‚úÖ Maneja ejecuci√≥n step-by-step con retry logic
# 3. ‚úÖ Implementa manejo avanzado de errores y recuperaci√≥n
# 4. ‚úÖ Genera respuestas estructuradas con evaluaci√≥n de calidad
```

---

## 7. Casos de Uso Pr√°cticos

### 7.1 Caso de Uso: "Analizar Documentaci√≥n de Python"

**Entrada del Usuario:**
```
"Busca informaci√≥n sobre decoradores en Python, 
cuenta cu√°ntos ejemplos encuentras y formatea 
un resumen ejecutivo"
```

**Plan Generado:**
```json
{
  "plan_id": "plan_20250816_143521_001",
  "goal": "Analizar documentaci√≥n de Python sobre decoradores",
  "steps": [
    {
      "step_id": 1,
      "action": "search",
      "tool": "search_documents",
      "parameters": {
        "query": "Python decoradores ejemplos",
        "max_results": 5
      },
      "expected_output": "documentos sobre decoradores",
      "validation_criteria": ["al menos 2 resultados"]
    },
    {
      "step_id": 2,
      "action": "calculate",
      "tool": "math_calculator",
      "parameters": {
        "expression": "count_examples_in_results"
      },
      "expected_output": "n√∫mero de ejemplos",
      "validation_criteria": ["resultado num√©rico >= 0"]
    },
    {
      "step_id": 3,
      "action": "format",
      "tool": "format_response",
      "parameters": {
        "content": "resumen_decoradores",
        "format": "executive_summary"
      },
      "expected_output": "resumen ejecutivo",
      "validation_criteria": ["longitud 100-300 palabras"]
    }
  ],
  "success_criteria": [
    "informaci√≥n recuperada",
    "ejemplos contabilizados",
    "resumen generado"
  ]
}
```

---

## 8. Patrones de Manejo de Errores

### 8.1 Estrategias de Recuperaci√≥n

```python
class ErrorRecoveryStrategy:
    """Estrategias para manejar errores en agentes"""
    
    RETRY_STRATEGIES = {
        'tool_timeout': 'retry_with_longer_timeout',
        'invalid_parameters': 'retry_with_corrected_params',
        'resource_unavailable': 'retry_with_alternative_tool',
        'partial_failure': 'continue_with_partial_results',
        'critical_error': 'abort_and_report'
    }
    
    def handle_error(self, error_type: str, context: Dict) -> str:
        """Determinar estrategia de recuperaci√≥n"""
        return self.RETRY_STRATEGIES.get(error_type, 'abort_and_report')
```

### 8.2 Circuit Breaker Pattern

```python
class CircuitBreaker:
    """Implementaci√≥n de circuit breaker para herramientas"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
    
    def call(self, func, *args, **kwargs):
        """Ejecutar funci√≥n con circuit breaker"""
        if self.state == 'OPEN':
            if time.time() - self.last_failure_time > self.timeout:
                self.state = 'HALF_OPEN'
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise e
```

---

## 9. M√©tricas y Evaluaci√≥n

### 9.1 M√©tricas del Agente

- **Tasa de √©xito de planes**: % de planes ejecutados exitosamente
- **Tiempo promedio de ejecuci√≥n**: Latencia por plan
- **Uso de herramientas**: Frecuencia y eficiencia
- **Tasa de retry**: % de pasos que requieren reintento
- **Precisi√≥n del Critic**: % de evaluaciones correctas

### 9.2 Dashboard de M√©tricas

```python
def generate_agent_metrics(execution_logs: List[Dict]) -> Dict:
    """Generar m√©tricas del agente"""
    total_plans = len(execution_logs)
    successful_plans = sum(1 for log in execution_logs if log['status'] == 'success')
    
    return {
        'success_rate': successful_plans / total_plans if total_plans > 0 else 0,
        'avg_execution_time': calculate_avg_time(execution_logs),
        'most_used_tools': get_tool_usage_stats(execution_logs),
        'error_patterns': analyze_error_patterns(execution_logs)
    }
```

---

## 10. Quiz de Evaluaci√≥n

### Pregunta 1
¬øCu√°l es la responsabilidad principal del componente Critic en el patr√≥n PEC?

- [ ] a) Generar planes de ejecuci√≥n
- [ ] b) Ejecutar herramientas externas
- [x] c) Evaluar resultados y decidir pr√≥ximos pasos
- [ ] d) Validar par√°metros de entrada

### Pregunta 2
¬øQu√© ventaja principal ofrece el patr√≥n PEC sobre un enfoque monol√≠tico?

- [ ] a) Mayor velocidad de ejecuci√≥n
- [x] b) Mejor modularidad y mantenibilidad
- [ ] c) Menor uso de memoria
- [ ] d) Compatibilidad con m√°s APIs

### Pregunta 3
¬øCu√°ndo debe un agente implementar circuit breaker pattern?

- [ ] a) Siempre, en todas las herramientas
- [ ] b) Nunca, es innecesario
- [x] c) Para herramientas externas propensas a fallos
- [ ] d) Solo en entornos de producci√≥n

---

## 11. Recursos Adicionales

### 11.1 Plantillas Descargables
- üìÑ [`pec-agent-template.py`](../../templates/pec-agent-template.py) - Template base de agente
- üìÑ [`tool-registry-config.json`](../../templates/tool-registry-config.json) - Configuraci√≥n de herramientas
- üìÑ [`error-handling-patterns.py`](../../templates/error-handling-patterns.py) - Patrones de manejo de errores

### 11.2 Lecturas Recomendadas
- [ReAct: Reasoning and Acting with Language Models](https://arxiv.org/abs/2210.03629)
- [Toolformer: Language Models Can Teach Themselves to Use Tools](https://arxiv.org/abs/2302.04761)
- [Circuit Breaker Pattern - Martin Fowler](https://martinfowler.com/bliki/CircuitBreaker.html)

---

## ‚úÖ Siguiente Paso

Una vez completado este m√≥dulo, estar√°s listo para **M√≥dulo C: RAG B√°sico con Citas**, donde implementar√°s recuperaci√≥n de informaci√≥n y generaci√≥n aumentada.

**üéØ Meta del pr√≥ximo m√≥dulo:** Crear un sistema RAG que pueda buscar, recuperar y citar informaci√≥n de forma confiable.

---

*¬øTienes dudas sobre el patr√≥n PEC? Revisa los [ejemplos completos](../examples/) o consulta el [foro de estudiantes](../community/).*
